## 虚拟 dom

> `虚拟DOM`（Virtual DOM）本质上是 `JS` 和 `DOM` 之间的一个`映射缓存`，它在形态上表现为一个能够描述 `DOM` 结构及其属性信息的 `JS` 对象

即：

1. `虚拟DOM`是`JS对象`
2. `虚拟DOM`是对`真实DOM`的描述

```js
const profile = (
  <div className="profile">
    <span className="profile-title">title</span>
    <h3 className="profile-content">content</h3>
    我是一段文本
  </div>
);
```

接下来要将上面 `JSX` 代码转化为下面的`数据结构`来描述

```js
// 对象来描述 jsx
const profile = {
    type: "div",
    props: {
       className: "profile",
       children: [
           {type: 'span', props: {…}},
           {type: 'h3', props: {…}},
           "我是一段文本"
       ],
   },
}
```

### 虚拟 DOM 如何工作

- `挂载阶段`: 通过`JSX` 的描述，构建出`虚拟 DOM` 树，然后通过 `render()` 关联`虚拟 DOM` 到`真实 DOM` 的映射；
- `更新阶段`: 新、旧`虚拟 DOM` 通过 `diff 算法`对比出需要改变的部分，然后再将这些改变作用于真实 DOM。

## 虚拟 DOM 和模板渲染的区别

- `一般开发`：数据 + 模版 --> 真实 dom --> 挂载
- `虚拟 dom`: 数据 + "模板"(jsx) --> 虚拟 dom --> 真实 dom -->挂载

注意：`虚拟 dom` 的“模板”二字加了引号，这是因为`虚拟 DOM` 在实现上并不总是借助模板。比如 React 就使用了 `JSX`，而`JSX` 本质不是模板，而是一种使用体验和模板相似的 `JS 语法糖`

> 区别就在于多出了一层`虚拟 DOM` 作为`缓冲层`。这个`缓冲层`带来的利好是：当 DOM 操作（渲染更新）比较`频繁`时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“`补丁集`”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“`差量更新`”。

## React 选用虚拟 DOM 为了更好的性能？

> 在整个`DOM操作`的演化过程中，主要矛盾并不在于`性能`，而在于开发者写得爽不爽，在于`研发体验/研发效率`。`虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物`

虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，`它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能`

`性能问题`属于前端领域复杂度比较高的问题。当我们`量化性能`的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论。

拿前面讲过的模板渲染来举例，我们可以对比一下它和虚拟 DOM 在性能开销上的差异。两者的渲染工作流对比如下图所示：

![](https://chao31.github.io/pics/img/202303201217928.png)