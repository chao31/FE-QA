看完这篇文章，我们可以弄明白下面这几个问题：

1. `React` 为什么要做 `diff` 算法？
2. `React` 的 `diff` 算法是怎么实现的？
3. `React` 的 `diff` 算法发生在哪个阶段？
4. `React` 的元素的 `key` 是做什么的？
5. `React` 是怎么通过 `key` 实现高效 `diff` 的？

## Fiber 节点的构建

下面的伪代码展示了 `fiber` 构建的过程：

```js
function workLoop(deadline) {
  // requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  // 循环调用 workLoop
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

// 构建完当前 fiber 节点后，会返回下一个待构建的节点 如：fiber.sibling、fiber.parent...
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```

- 不熟悉 `requestIdleCallback` 可以点[这里查看](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，这个方法很简单：它需要传入一个 `callback`，浏览器会在空闲时去调用这个 `callback`，然后给这个 `callback` 传入一个 `IdleDeadline`，`IdleDeadline` 会预估一个剩余闲置时间，我们可以通过还剩多少闲置时间去判断，是否足够去执行下一个单元任务。
- `performUnitOfWork` 方法将传入的`节点`创建为 `Fiber` ，然后返回下一个待构建的`节点`并赋值给 `nextUnitOfWork`，同时还会将刚创建的 `fiber` 与已创建的 `fiber` 连接起来构成 `Fiber` 树。

`performUnitOfWork` 的工作可以分为两部分：“`递`”和“`归`”。

## 从 rootFiber 开始向下深度优先遍历

首先从 rootFiber 开始向下深度优先遍历