## Context 使用

> 在平时工作中的某些场景下，你可能想在整个组件树中传递数据，但却不想手动地通过 `props` 属性在每一层传递属性，`contextAPI` 应用而生。

## 函数组件用法

### 1. 先创建 createContext

使用 `createContext` 创建并初始化

```js
// theme-context.js
export const C = createContext(defaultValue);
```

### 2. Provider 指定使用的范围

```js
// 在圈定的范围内，传入读操作和写操作对象，然后可以使用上下文
    <C.Provider value={{n,setN}}>
      这是爷爷
      <Father></Father>
    </C.Provider>
```

### 3. 最后使用 useContext 或 Consumer

- useContext 
使用 `useContext` 接受上下文，因为传入的是对象，则接受的也应该是对象

```js
const {n, setN} = useContext(C)；
```

- Context.Consumer

```js
import {C} from './theme-context';

function Child(){
  return(
    <C.Consumer>
        {(n, setN) => {
            const add=()=> setN(n=>n+1);
            return (
                <div>
                    这是儿子:{n}
                    <button onClick={add}>点击加 1</button>
                </div>
            )
        }}
    </C.Consumer>
  )
}

```


案例：在孙子组件中使用爷爷组件中定义的变量 n，并且进行 +1 操作

```js
import React, { createContext, useContext, useReducer, useState } from 'react'
import ReactDOM from 'react-dom'

// 创造一个上下文
const C = createContext(null);

function App(){
  const [n,setN] = useState(0)
  return(
    // 指定上下文使用范围，使用 provider，并传入读数据和写入据
    <C.Provider value={{n,setN}}>
      这是爷爷
      <Father></Father>
    </C.Provider>
  )
}

function Father(){
  return(
    <div>
      这是爸爸
      <Child></Child>
    </div>
  )
}

function Child(){
  // 使用上下文，因为传入的是对象，则接受也应该是对象
  const {n, setN} = useContext(C)
  const add=()=>{
    setN(n=>n+1)
  };
  return(
    <div>
      这是儿子:n:{n}
      <button onClick={add}>+1</button>
    </div>
  )
}


ReactDOM.render(<App />,document.getElementById('root'));
```

## class 组件用法