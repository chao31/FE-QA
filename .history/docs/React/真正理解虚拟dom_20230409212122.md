读完本文，你可以学到：

虚拟 dom 的理解：

1. 制约`快速响应`的因素 :cpu 瓶颈和 io 瓶颈，io 涉及网路传输部分不可控；cup 瓶颈涉及性能，那虚拟 dom 的价值在于更好的性能？
2. 否，老旧设备有性能问题，现在的硬件都很优秀；而在在整个 DOM 操作的演化过程中，主要矛盾并不在于性能，而在研发效率；
3. react 官方也没有将虚拟 dom 的性能提升作为一大卖点，重要的是提供了函数式的 UI 编程方式的同时有一个优秀的性能；
4. 如果不用虚拟 dom，会用模板渲染，区别就是虚拟 dom 做大量的 diff 计算，而模板渲染是字符串的拼接
5. 若页面几乎全部更新，那么做了大量 diff 计算就相当于浪费了很多性能，但大多数情况下，我们的页面局部更新较多，这时差量更新的效率显然是高于全量更新，另外节省的是更少的 dom 操作，极少的 dom 操作是可以支持巨大的 js 计算的
6. 虚拟 dom 是对真实渲染内容的一层抽象，
## 虚拟 dom 是什么

> `虚拟DOM`（Virtual DOM）本质上是 `JS` 和 `DOM` 之间的一个`映射缓存`，它在形态上表现为一个能够描述 `DOM` 结构及其属性信息的 `JS` 对象

即：

1. `虚拟DOM`是`JS对象`
2. `虚拟DOM`是对`真实DOM`的描述

```js
const profile = (
  <div className="profile">
    <span className="profile-title">title</span>
    <h3 className="profile-content">content</h3>
    我是一段文本
  </div>
);
```

接下来要将上面 `JSX` 代码转化为下面的`数据结构`来描述

```js
// 对象来描述 jsx
const profile = {
    type: "div",
    props: {
       className: "profile",
       children: [
           {type: 'span', props: {…}},
           {type: 'h3', props: {…}},
           "我是一段文本"
       ],
   },
}
```

### 虚拟 DOM 如何工作

- `挂载阶段`: 通过`JSX` 的描述，构建出`虚拟 DOM` 树，然后通过 `render()` 关联`虚拟 DOM` 到`真实 DOM` 的映射；
- `更新阶段`: 新、旧`虚拟 DOM` 通过 `diff 算法`对比出需要改变的部分，然后再将这些改变作用于真实 DOM。

## 虚拟 DOM 和模板渲染的区别

- `模板渲染`：数据 + 模版 --> 真实 dom --> 挂载
- `虚拟 dom`: 数据 + "模板"(jsx) --> 虚拟 dom --> 真实 dom -->挂载

注意：`虚拟 dom` 的“模板”二字加了引号，这是因为`虚拟 DOM` 在实现上并不总是借助模板。比如 React 就使用了 `JSX`，而`JSX` 本质不是模板，而是一种使用体验和模板相似的 `JS 语法糖`

> 区别就在于多出了一层`虚拟 DOM` 作为`缓冲层`。这个`缓冲层`带来的利好是：当 DOM 操作（渲染更新）比较`频繁`时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“`补丁集`”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“`差量更新`”。

## React 选用虚拟 DOM 为了更好的性能？

> 在整个`DOM操作`的演化过程中，主要矛盾并不在于`性能`，而在于开发者写得爽不爽，在于`研发体验/研发效率`。`虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物`

虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，`它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能`

`性能问题`属于前端领域复杂度比较高的问题。当我们`量化性能`的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论。

### 对比
还是拿`模板渲染`来举例，对比一下它和`虚拟 DOM` 在性能开销上的差异：

![](https://chao31.github.io/pics/img/202303201217928.png)

1. `JS 范畴`：`模板渲染`的步骤 1，和`虚拟 DOM 渲染`的步骤 1、2 都属于 `JS 范畴`的行为，这两者是具备可比性的，放在一起对比：
  - 动态生成 HTML 字符串的过程本质是`对字符串的拼接`，对性能的消耗是有限的；
  - 而虚拟 DOM 的构建和 diff 过程逻辑则相对复杂，它不可避免地涉及递归、遍历等耗时操作。

因此在`JS 行为`这个层面，`模板渲染`胜出。

2. `DOM 范畴`：`模板渲染`的步骤 3，和`虚拟 DOM` 的步骤 3 都属于 `DOM 范畴`的行为，两者具备可比性，对比：
  - 模板渲染是`全量`更新;
  - 而虚拟 DOM 是`差量`更新，`差量更新`比`全量更新`更高效。

因此在`DOM范畴`，`虚拟dom`胜出。

但上面的对比得出的结论是不准确的：

虽然`差量更新`比`全量更新`更高效，但如果数据量变化很大（或者说整个页面发生了改变），那`差量更新`计算出来的结果和`全量更新`基本是一样的。在这种更新量`基本一致`，而`虚拟 DOM` 却伴随着更大的 diff 计算开销的情况下，`模板渲染`和`虚拟 DOM `在整体性能上是`难分伯仲`的：
  - 若两者最终计算出的 DOM 更新内容`完全一致`，那么`虚拟 DOM` 大概率不敌`模板渲染`；
  - 但只要两者在最终 DOM 操作量上拉开那么一点点的差距，`虚拟 DOM` 就将具备战胜`模板渲染`的底气。因为虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 `DOM 操作的能耗和 JS 计算的能耗根本不在一个量级，极少量的 DOM 操作耗费的性能足以支撑大量的 JS 计算`。
  - 但在实际的开发中，上面的情况属于在极端情况下，而更加高频的场景是：频繁的 `setState` 只修改少量的数据，由于交互频繁的局部更新。在这样的场景下，`模板渲染`和`虚拟 DOM` 之间 DOM 操作量级的差距就完全拉开了，`虚拟 DOM `将在性能上具备`绝对的优势`

总结：`虚拟DOM` 在多数情况下，占据着性能优势，但性能的量化是复杂的，并非所有情况下都有优势。

## 那么虚拟 DOM 的价值到底是什么呢？

- `研发体验/研发效率的问题`：DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为`数据驱动视图`这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。
- `跨平台的问题`：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么`视图层`将和`渲染平台`紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是`真实 DOM`，也可以是 `iOS 界面`、`安卓界面`、`小程序`......同一套虚拟 DOM，可以对接`不同平台`的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和 1 是高度呼应的。

![](https://chao31.github.io/pics/img/202303201245470.png)

除了`差量更新`以外，“`批量更新`”也是虚拟 DOM 在性能方面所做的一个重要努力：“`批量更新`”在通用虚拟 DOM 库里是由 `batch` 函数来处理的。在差量更新速度非常快的情况下（比如极短的时间里多次操作同一个 DOM），用户实际上只能看到最后一次更新的效果。这种场景下，前面几次的更新动作虽然意义不大，但都会触发重渲染流程，带来大量不必要的高耗能操作，这时就需要请 `batch` `来帮忙了，batch` 的作用是`缓冲`每次生成的`补丁集`，它会把收集到的多个补丁集暂存到`队列`中，再将`最终的结果`交给渲染函数，最终实现集中化的 DOM `批量更新`








