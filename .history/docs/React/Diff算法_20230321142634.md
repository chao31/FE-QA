看完这篇文章，我们可以弄明白下面这几个问题：

1. `React` 为什么要做 `diff` 算法？
2. `React` 的 `diff` 算法是怎么实现的？
3. `React` 的 `diff` 算法发生在哪个阶段？
4. `React` 的元素的 `key` 是做什么的？
5. `React` 是怎么通过 `key` 实现高效 `diff` 的？

## Fiber 节点的构建

下面的伪代码展示了 `fiber` 构建的过程：

```js
function workLoop(deadline) {
  // requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  // 循环调用 workLoop
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

// 构建完当前 fiber 节点后，会返回下一个待构建的节点 如：fiber.sibling、fiber.parent...
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```

- 不熟悉 `requestIdleCallback` 可以点[这里查看](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，这个方法很简单：它需要传入一个 `callback`，浏览器会在空闲时去调用这个 `callback`，然后给这个 `callback` 传入一个 `IdleDeadline`，`IdleDeadline` 会预估一个剩余闲置时间，我们可以通过还剩多少闲置时间去判断，是否足够去执行下一个单元任务。
- `performUnitOfWork` 方法将传入的`节点`创建为 `Fiber` ，然后返回下一个待构建的`节点`并赋值给 `nextUnitOfWork`，同时还会将刚创建的 `fiber` 与已创建的 `fiber` 连接起来构成 `Fiber` 树。

`performUnitOfWork` 的工作可以分为两部分：“`递`”和“`归`”。

## render 阶段

render 阶段的开始，首先从 `rootFiber` 开始向下`深度优先`遍历，也就是不断 `while` 循环执行 `performUnitOfWork`，会经历`递`和`归`两个阶段。

### “递”阶段

- 向下遍历，每个遍历到的 `Fiber` 节点会调用 `beginWork` 方法。
- 该方法会根据传入的 `Fiber` 节点创建`子Fiber` 节点，并将这两个 `Fiber` 节点`连接`起来。
- 当遍历到没有 `child` 的节点时就会进入“归”阶段。

### “归”阶段

- 在“归”阶段会调用 `completeWork`  处理 `Fiber` 节点。
- 当某个 `Fiber` 节点执行完 `completeWork`，如果其存在`兄弟Fiber`节点，会进入其`兄弟Fiber`的“递”阶段。
- 如果不存在`兄弟Fiber`，会进入`父Fiber`的“归”阶段。

### 递和归举例
```js
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```
对应的 Fiber 树结构：

![](https://chao31.github.io/pics/img/202303211355838.png)

render 阶段会依次执行：

```js
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

注意：之所以没有`“KaSong”`Fiber 的 `beginWork/completeWork`，是因为作为一种性能优化手段，针对只有单一文本子节点的 `Fiber`，`React` 会特殊处理。

### render 完成

“递”和“归”阶段会交错执行直到“归”到 `rootFiber`。至此，`render` 阶段的工作就结束了。

## Diff

`diff 算法`发生在两个阶段，分别是 `beginWork` 和 `completeWork` 阶段。

### Diff 的瓶颈以及 React 如何应对

由于 `Diff` 操作本身也会带来性能损耗，`React` 文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。
如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。
为了降低算法复杂度，React 的 diff 会预设三个限制：

1. 只进行`同层比较`。
2. 新、旧节点的 `type` 不同，直接`删除`旧节点，`创建`新节点。如：元素由 `div` 变为 `p`，React` 会销毁 `div` 及其子孙节点，并新建 `p` 及其子孙节点。
3. 通过 `key` 来`复用`节点。

所以 `react` 中 `diff` 算法主要遵循上面的三个层级的策略：

1. `tree` 层级
2. `conponent` 层级
3. `element` 层级

#### tree 层级

`DOM` 节点跨层级的操作不做优化，只会对相同层级的节点进行比较

![](https://chao31.github.io/pics/img/202303211415634.png)

只有删除、创建操作，没有移动操作，如下图：
![](https://chao31.github.io/pics/img/202303211416464.png)

`react` 发现新树中，`R` 节点下没有了 `A`，那么直接删除 `A`，在 `D` 节点下创建 `A` 以及下属节点，上述操作中，只有删除和创建操作

#### component 层级

如果是同一个类的组件，则会继续往下 `diff` 运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的

![](https://chao31.github.io/pics/img/202303211418926.png)

当 component D 换成了 component G 后，即使两者的结构非常类似，也会将 D 删除再重新创建 G

#### element 层级
对于比较同一层级的节点们，每个节点在对应的层级用唯一的 `key` 作为标识

提供了 3 种节点操作，分别为 `INSERT_MARKUP`(插入)、`MOVE_EXISTING` (移动) 和 `REMOVE_NODE` (删除)

如下场景：

![](https://chao31.github.io/pics/img/202303211419967.png)

通过 `key` 可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置

### Diff 是如何实现的

我们从 `Diff` 的入口函数 `reconcileChildFibers` 出发，该函数会根据 `newChild`（即 JSX 对象）类型调用不同的处理函数。

```js
// 根据 newChild 类型选择不同 diff 函数处理
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
): Fiber | null {

  const isObject = typeof newChild === 'object' && newChild !== null;

  if (isObject) {
    // object 类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // 调用 reconcileSingleElement 处理
      // // ...省略其他 case
    }
  }

  if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 调用 reconcileSingleTextNode 处理
    // ...省略
  }

  if (isArray(newChild)) {
    // 调用 reconcileChildrenArray 处理
    // ...省略
  }

  // 一些其他情况调用处理函数
  // ...省略

  // 以上都没有命中，删除节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

我们可以从同级的节点数量将 `Diff` 分为两类：

- 当 `newChild` 类型为 `object`、`number`、`string`，代表同级只有一个节点
- 当 `newChild` 类型为 `Array`，同级有多个节点

在接下来两节我们会分别讨论这两类节点的 `Diff`

### 单节点 diff

对于单个节点，我们以类型 object 为例，会进入 reconcileSingleElement




