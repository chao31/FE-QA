## React 生命周期

![](img/a.jpg)

### 挂载

当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：

```js
// 挂载之前
constructor() 
// 渲染
render()
// 挂载之后
componentDidMount() // 接口请求的地方
```

### 更新

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- render()
- componentDidUpdate()

### 卸载

当组件从 DOM 中移除时会调用如下方法：

- componentWillUnmount()

参考：

[1. React.Component](https://zh-hans.reactjs.org/docs/react-component.html)

[2. 图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

---

## React 的请求应该放在哪里，为什么？这也是经常会被追问的问题

对于异步请求，应该放在 `componentDidMount` 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择：

- ~~constructor~~：可以放，但从设计上而言不推荐。通常，在 React 中，构造函数仅用于以下两种情况：
  - 通过给 `this.state` 赋值来初始化 `state`
  - 为事件处理函数绑定实例

- ~~componentWillMount~~：已废弃，不推荐使用，主要原因是`新的异步渲染架构会导致它被多次调用`,所以应放至 `componentDidMount` 中。

- `componentDidUpdate`: 如当 `props` 发生变化时，则执行网络请求，但注意，若请求回调里调用了 setState()，需确保必须被包裹在一个条件语句里，否则会导致死循环。

## React 合成事件机制

- `React16`事件绑定到`document`上
- `React17`事件绑定到`root`组件上，有利于多个 react 版本共存，例如微前端
- React 里的`event`不是原生的，而是自己实现的`合成事件对象`——`SyntheticEvent`
- 若想操作原生`event`，通过`e.nativeEvent`

![](https://chao31.github.io/pics/img/202303181812326.png)

合成事件图示：

![](https://chao31.github.io/pics/img/202303181813466.png)

### 为何需要合成事件

- 更好的兼容性和跨平台，把 IE 和 W3C 标准之间的兼容问题给消除了
- 挂载到`document`或`root`上，减少内存消耗，避免频繁解绑

```js
// 获取 event
clickHandler3 = (event) => {
    event.preventDefault() // 阻止默认行为
    event.stopPropagation() // 阻止冒泡
    console.log('target', event.target) // 指向当前元素，即当前元素触发
    console.log('current target', event.currentTarget) // 指向当前元素，假象！！！

    // 注意，event 其实是 React 封装的。可以看 __proto__.constructor 是 SyntheticEvent 组合事件
    console.log('event', event) // 不是原生的 Event，原生的 MouseEvent
    console.log('event.__proto__.constructor', event.__proto__.constructor)

    // 原生 event 如下。其 __proto__.constructor 是 MouseEvent
    console.log('nativeEvent', event.nativeEvent)
    console.log('nativeEvent target', event.nativeEvent.target)  // 指向当前元素，即当前元素触发
    console.log('nativeEvent current target', event.nativeEvent.currentTarget) // 指向 document！！！

    // 1. event 是 SyntheticEvent，模拟出来 DOM 事件所有能力
    // 2. event.nativeEvent 是原生事件对象
    // 3. 所有的事件，都被挂载到 document 或`root` 上
    // 4. 和 DOM 事件不一样，和 Vue 事件也不一样
}
```

## setState
- `State` 的更新可能是`异步`的，出于性能考虑，`React` 可能会把多个 `setState()` 调用合并成一个调用。

```js
class Home extends React.Component {
  constructor() {
    super()
    this.state = {
      val: 0
    }
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 }) 
    console.log(this.state.val)
    
    this.setState({ val: this.state.val + 1}) 
    console.log(this.state.val)
  }

  render() {
    return <h1 className="home-title">Home111~~~{this.state.val}</h1>;
  }
}

export default Home;

// 0
// 0
```
- `setState`在`react`事件、生命周期中是异步的（在`react`上下文中是异步）；在`setTimeout`、自定义`DOM`事件中是同步的
- 有时合并（对象形式 setState({}) => 通过 Object.assign 形式合并对象），有时不合并（函数形式 setState((prevState,nextState)=>{})）

