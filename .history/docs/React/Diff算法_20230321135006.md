看完这篇文章，我们可以弄明白下面这几个问题：

1. `React` 为什么要做 `diff` 算法？
2. `React` 的 `diff` 算法是怎么实现的？
3. `React` 的 `diff` 算法发生在哪个阶段？
4. `React` 的元素的 `key` 是做什么的？
5. `React` 是怎么通过 `key` 实现高效 `diff` 的？

## Fiber 节点的构建

下面的伪代码展示了 `fiber` 构建的过程：

```js
function workLoop(deadline) {
  // requestIdleCallback 给 shouldYield 赋值，告诉我们浏览器是否空闲
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  // 循环调用 workLoop
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

// 构建完当前 fiber 节点后，会返回下一个待构建的节点 如：fiber.sibling、fiber.parent...
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```

- 不熟悉 `requestIdleCallback` 可以点[这里查看](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，这个方法很简单：它需要传入一个 `callback`，浏览器会在空闲时去调用这个 `callback`，然后给这个 `callback` 传入一个 `IdleDeadline`，`IdleDeadline` 会预估一个剩余闲置时间，我们可以通过还剩多少闲置时间去判断，是否足够去执行下一个单元任务。
- `performUnitOfWork` 方法将传入的`节点`创建为 `Fiber` ，然后返回下一个待构建的`节点`并赋值给 `nextUnitOfWork`，同时还会将刚创建的 `fiber` 与已创建的 `fiber` 连接起来构成 `Fiber` 树。

`performUnitOfWork` 的工作可以分为两部分：“`递`”和“`归`”。

## 从 rootFiber 开始向下遍历

首先从 `rootFiber` 开始向下`深度优先`遍历，也就是不断 `while` 循环执行 `performUnitOfWork`，会经历`递`和`归`两个阶段。

### “递”阶段

- 向下遍历，每个遍历到的 `Fiber` 节点会调用 `beginWork` 方法。
- 该方法会根据传入的 `Fiber` 节点创建`子Fiber` 节点，并将这两个 `Fiber` 节点`连接`起来。
- 当遍历到没有 `child` 的节点时就会进入“归”阶段。

### “归”阶段

在“归”阶段会调用 completeWork (opens new window) 处理 Fiber 节点。

当某个 Fiber 节点执行完 completeWork，如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。

如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。

“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。