## React 生命周期

![](img/a.jpg)

### 挂载

当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：

```js
// 挂载之前
constructor() 
// 渲染
render()
// 挂载之后
componentDidMount() // 接口请求的地方
```

### 更新

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- render()
- componentDidUpdate()

### 卸载

当组件从 DOM 中移除时会调用如下方法：

- componentWillUnmount()

参考：

[1. React.Component](https://zh-hans.reactjs.org/docs/react-component.html)

[2. 图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

---

## React 的请求应该放在哪里，为什么？这也是经常会被追问的问题

对于异步请求，应该放在 `componentDidMount` 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择：

- ~~constructor~~：可以放，但从设计上而言不推荐。通常，在 React 中，构造函数仅用于以下两种情况：
  - 通过给 `this.state` 赋值来初始化 `state`
  - 为事件处理函数绑定实例

- ~~componentWillMount~~：已废弃，不推荐使用，主要原因是`新的异步渲染架构会导致它被多次调用`,所以应放至 `componentDidMount` 中。

- `componentDidUpdate`: 如当 `props` 发生变化时，则执行网络请求，但注意，若请求回调里调用了 setState()，需确保必须被包裹在一个条件语句里，否则会导致死循环。

## React 合成事件机制

- `React16`事件绑定到`document`上
- `React17`事件绑定到`root`组件上，有利于多个 react 版本共存，例如微前端
- React 里的`event`不是原生的，而是自己实现的`合成事件对象`——`SyntheticEvent`
- 若想操作原生`event`，通过`e.nativeEvent`

![](https://chao31.github.io/pics/img/202303181812326.png)

合成事件图示：

![](https://chao31.github.io/pics/img/202303181813466.png)

### 为何需要合成事件

- 更好的兼容性和跨平台，把 IE 和 W3C 标准之间的兼容问题给消除了
- 挂载到`document`或`root`上，减少内存消耗，避免频繁解绑

```js
// 获取 event
clickHandler3 = (event) => {
    event.preventDefault() // 阻止默认行为
    event.stopPropagation() // 阻止冒泡
    console.log('target', event.target) // 指向当前元素，即当前元素触发
    console.log('current target', event.currentTarget) // 指向当前元素，假象！！！

    // 注意，event 其实是 React 封装的。可以看 __proto__.constructor 是 SyntheticEvent 组合事件
    console.log('event', event) // 不是原生的 Event，原生的 MouseEvent
    console.log('event.__proto__.constructor', event.__proto__.constructor)

    // 原生 event 如下。其 __proto__.constructor 是 MouseEvent
    console.log('nativeEvent', event.nativeEvent)
    console.log('nativeEvent target', event.nativeEvent.target)  // 指向当前元素，即当前元素触发
    console.log('nativeEvent current target', event.nativeEvent.currentTarget) // 指向 document！！！

    // 1. event 是 SyntheticEvent，模拟出来 DOM 事件所有能力
    // 2. event.nativeEvent 是原生事件对象
    // 3. 所有的事件，都被挂载到 document 或`root` 上
    // 4. 和 DOM 事件不一样，和 Vue 事件也不一样
}
```

## setState
- `State` 的更新可能是`异步`的，出于性能考虑，`React` 可能会把多个 `setState()` 调用合并成一个调用。
- 因为 `this.props` 和 `this.state` 可能会异步更新，所以你不要依赖他们的值来更新下一个状态，需要`setState((prevState,nextState)=>{})`


多个 `setState()` 被合并：

```js
class Home extends React.Component {
  constructor() {
    super()
    this.state = {
      val: 0
    }
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 }) 
    console.log(this.state.val)
    
    this.setState({ val: this.state.val + 1}) 
    console.log(this.state.val)
  }

  render() {
    return <h1 className="home-title">Home111~~~{this.state.val}</h1>;
  }
}

export default Home;

// 0
// 0
```
setTimeout 里的多个 `setState()` 也会被合并：

```js
class Home extends React.Component {
  constructor() {
  super()
  this.state = {
    val: 0
  }
}
componentDidMount() {
  this.setState({ val: this.state.val + 1 }) 
  console.log(0, this.state.val)
  
  this.setState({ val: this.state.val + 1}) 
  console.log(1, this.state.val)
  
  setTimeout(() => {
    this.setState({ val: this.state.val + 1 }) 
    console.log(2, this.state.val)
    
    this.setState({ val: this.state.val + 1 }) 
    console.log(3, this.state.val)
    
    }, 0)
  }
  render() {
    return <h1 className="home-title">Home111~~~{this.state.val}</h1>;
  }
}

// 0 0
// 1 0 
// 2 1
// 3 1
```

## 为什么 React 元素有一个 $$typeof 属性

目的是为了防止 `XSS` 攻击。因为 `Synbol` 无法被序列化，所以 `React` 可以通过有没有 `$$typeof` 属性来断出当前的 `element` 对象是从数据库来的还是自己生成的。如果没有 `$$typeof` 这个属性，react 会拒绝处理该元素。

## React 有哪些优化性能的手段

- 类组件中的优化手段：

1. 使用纯组件 `PureComponent` 作为基类。
2. 使用 `shouldComponentUpdate` 生命周期函数来自定义渲染逻辑。
3. 方法组件中的优化手段

- 使用 `React.memo` 高阶函数包装组件，`React.memo` 可以实现类似于 `shouldComponentUpdate` 或者 `PureComponent` 的效果
1. 使用 `useMemo`
2. 使用 `React.useMemo`精细化的管控，`useMemo` 控制的则是是否需要重复执行某一段逻辑，而 React.memo 控制是否需要重渲染一个组件
3. 使用 `useCallBack`

- 其他方式：

1. 在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
2. 必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
3. 使用 Suspense 和 lazy 进行懒加载，