## 虚拟 dom

> `虚拟DOM`（Virtual DOM）本质上是 `JS` 和 `DOM` 之间的一个`映射缓存`，它在形态上表现为一个能够描述 `DOM` 结构及其属性信息的 `JS` 对象

```js
const profile = (
  <div className="profile">
    <span className="profile-title">title</span>
    <h3 className="profile-content">content</h3>
    我是一段文本
  </div>
);
```

接下来要将上面 `JSX` 代码转化为下面的`数据结构`来描述

```js
// 对象来描述 jsx
const profile = {
    type: "div",
    props: {
       className: "profile",
       children: [
           {type: 'span', props: {…}},
           {type: 'h3', props: {…}},
           "我是一段文本"
       ],
   },
}
```

就这个示例来说，你需要把握住以下两点：

1. `虚拟DOM` 是 `JS` 对象
2. `虚拟DOM` 是对真实 `DOM` 的描述

我们看看 React 中的虚拟 DOM 大致是如何工作的

- `挂载阶段`: 通过`JSX` 的描述，构建出`虚拟 DOM` 树，然后通过 `render()` 关联`虚拟 DOM` 到`真实 DOM` 的映射；
- `更新阶段`: 新、旧`虚拟 DOM` 通过 `diff 算法`对比出需要改变的部分，然后再将这些改变作用于真实 DOM。

## 虚拟 DOM 是如何解决问题的

- 一般开发：数据 + 模版 --> 真实 dom --> 挂载
- 虚拟 dom: 数据 + "模板"(jsx) --> 虚拟 dom --> 真实 dom -->挂载

注意`虚拟 dom` 的“模板”二字加了引号，这是因为`虚拟 DOM` 在实现上并不总是借助模板。比如 React 就使用了 `JSX`，而`JSX` 本质不是模板，而是一种使用体验和模板相似的 `JS 语法糖`

区别就在于多出了一层`虚拟 DOM` 作为`缓冲层`。这个`缓冲层`带来的利好是：当 DOM 操作（渲染更新）比较`频繁`时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“`补丁集`”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“`差量更新`”。