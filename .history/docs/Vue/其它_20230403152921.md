## 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 检测差异

- 响应式数据变化，Vue 确实可以在数据变化时，响应式系统可以立刻得知。但是如果给每个属性都添加 `watcher` 用于更新的话，会产生大量的 `watcher` 从而降低性能
- 而且粒度过细也得导致更新不准确的问题，所以 `vue` 采用了组件级的 `watcher` 配合 `diff` 来检测差异

## Vue 组件之间通信方式有哪些

> Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：`父子`组件通信、`隔代`组件通信、`兄弟`组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信

- `props / $emit` : 适用 父子组件通信
  - 父组件向子组件传递数据是通过 `prop` 传递的，子组件传递数据给父组件是通过 `$emit` 触发事件来做到的
- `EventBus （$emit / $on）`: 适用于 父子、隔代、兄弟组件通信
- `provider / inject` :适用于 隔代组件通信
  - 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provider / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系
- `Vuex`: 适用于 父子、隔代、兄弟组件通信
  - 改变 `store` 中的状态的唯一途径就是显式地提交 `(commit) mutation`。这样使得我们可以方便地跟踪每一个状态的变化

## Vue 组件为什么只能有一个根元素

vue3 中没有问题

```js
Vue.createApp({
  components: {
    comp: {
      template: `
        <div>root1</div>
        <div>root2</div>
      `
    }
  }
}).mount('#app')
```

vue2 中组件确实只能有一个根，但 vue3 中组件已经可以多根节点了。
之所以需要这样是因为 vdom 是一颗单根树形结构，patch 方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个 vdom
vue3 中之所以可以写多个根节点，是因为引入了 Fragment 的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个 Fragment 节点，把多个根节点作为它的 children。将来 patch 的时候，如果发现是一个 Fragment 节点，则直接遍历 children 创建或更新