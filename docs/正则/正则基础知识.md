## 元字符

| 元字符 | 描述 | 
| ---   | --- | 
| `\d` | 数字 | 
| `\w` | 数字、字母、下划线 | 
| `\s` | 空格 | 
| `.` | 可以匹配任意字符 | 

## 量词

| 表达式 | 描述 |
| ---   | --- |
| `n*` | `n >= 0`, 零个或多个 n 的字符串 |
| `n+` | `n >= 1`, 表示至少一个字符 |
| `n？` | `n == 0 \|\| n == 1`, 表示 0 个或 1 个字符 |
| `{n}` | 表示 n 个字符，`{n,m}`表示 n-m 个字符|
|  `数量?` | 表示匹配模式是非贪婪的，见下面 |

`数量?`：
1. 当`?`跟在上面字符后时,即跟在(*, +, ?, {n}, {n,m}) 后时，匹配模式是非贪婪的（正则默认都是贪婪匹配） 
2. 非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。
3. 例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'  

## 方括号

| 表达式 | 描述 |
| ---   | --- |
|`[abc]`|查找方括号之间的任何一个字符。
|`[^abc]`|查找任何不在方括号之间的字符。
|`[0-9]`| 查找任何从 0 至 9 的数字。
|`[a-z]`| 查找任何从小写 a 到小写 z 的字符。

```js
// [abc]是查找方括号之间的任何一个字符。如：
'a,b, c d'.split(/[\s,]+/); // ['a', 'b', 'c', 'd']
```

## 其他

| 量词 | 描述 |
| ---   | --- |
|`n$`| 匹配任何结尾为 n 的字符串。
|`^n`| 匹配任何开头为 n 的字符串。
| `A\|B`| 可以匹配A或B     

## 修饰符

| 修饰符 | 描述 |
| ---   | --- |
| `i` | 大小写不敏感 |
| `g` | 全局匹配 |
| `m` | 多行匹配 |

## 解读1个小例子

来看一个复杂的例子：`\d{3}\s+\d{3,8}`。

我们来从左到右解读一下：

1. `\d{3}`表示匹配3个数字，例如'010'；

2. `\s`可以匹配一个空格（也包括Tab等空白符），所以`\s+`表示至少有一个空格，例如匹配' '，'\t\t'等；

3. `\d{3,8}`表示3-8个数字，例如'1234567'。

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是`\d{3}\-\d{3,8}`

## 2种创建方式

1. `/正则表达式/`
2. `new RegExp('正则表达式')`

```js
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```

## RegExp 对象方法

| 方法 | 描述 |
| ---  | --- |
| [exec](https://www.runoob.com/jsref/jsref-exec-regexp.html)| 如果字符串中有匹配的值返回该匹配值，否则返回 null，如：` /.+\?(.+)$/.exec('xx?aa=345&bb=123')` </br> 1. 返回 `["xx?aa=345&bb=123", "aa=345&bb=123", ...]`</br> 2. index = 0 对应`/.+\?(.+)$/`, index = 1 对应`(.+)` </br>3. 第 0 个值是匹配的字符串，后面的 1,2..是分组 |
| [test](https://www.runoob.com/jsref/jsref-test-regexp.html) | test() 方法用于检测一个字符串是否匹配某个模式 |


```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
```

## 支持正则的 String 方法

| 方法 | 描述 |
| ---  | --- |
| [match](https://www.runoob.com/jsref/jsref-match.html) | 找到一个或多个正则表达式的匹配，如下举例 |
| [replace](https://www.runoob.com/jsref/jsref-replace.html) | `s.replace(search,replaceStr)`,若`replaceStr`为函数，则这个函数的第一个参数：`匹配到的字符串`，中间参数为`分组`，例如：`'target[2].a'.replace(/\[(.)\]/g, '.$1.')` ，替换`[xxx]`为`.xxx.`,打印：`'target.2..a'` |
| [search](https://www.runoob.com/jsref/jsref-search.html) | 同`indexOf`，区别是可以传正则 |
| [split](https://www.runoob.com/jsref/jsref-split.html) | 可传入正则|


```js
// match
let str="The rain in SPAIN stays mainly in the plain"; 
str.match(/ain/g); // ['ain', 'ain', 'ain']
str.match(/ain/); // ['ain']

// search
let str="Mr. Blue has a blue house";
str.search("blue") // 15
```

* `match`赖于 `regexp` 是否具有标志 `g`,无则返回一个，有则返回多个

## 分组

用()表示的就是要提取的分组（Group）,比如：

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```
如果正则表达式中定义了组，就可以在RegExp.exec()方法提取出子串来。

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

## 贪婪匹配

需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：

```js
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。

必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：

```js
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

## 参考
1. [菜鸟](https://www.runoob.com/regexp/regexp-metachar.html)
2. [阮一峰](https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488)